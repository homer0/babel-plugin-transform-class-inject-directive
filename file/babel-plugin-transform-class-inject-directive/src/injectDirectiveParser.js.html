<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">babel-plugin-transform-class-inject-directive/src/injectDirectiveParser.js | babel-plugin-transform-class-inject-directive</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Detect an inject directive on a class constructor and define a static property with the list of dependencies."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="babel-plugin-transform-class-inject-directive"><meta property="twitter:description" content="Detect an inject directive on a class constructor and define a static property with the list of dependencies."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/homer0/babel-plugin-transform-class-inject-directive"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#src">src</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/babel-plugin-transform-class-inject-directive/src/injectDirectiveParser.js~InjectDirectiveParser.html">InjectDirectiveParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-plugin">plugin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-BabelPluginTransformClassInjectDirective">BabelPluginTransformClassInjectDirective</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ClassMethodVisitor">ClassMethodVisitor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FunctionDeclarationVisitor">FunctionDeclarationVisitor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-FunctionExpressionVisitor">FunctionExpressionVisitor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ParserCallback">ParserCallback</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ProgramVisitor">ProgramVisitor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ProgramVisitorFinish">ProgramVisitorFinish</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ProgramVisitorStart">ProgramVisitorStart</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Visitors">Visitors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md">AssignmentExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md">ExpressionStatement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md">Node</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-paths">Path</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">babel-plugin-transform-class-inject-directive/src/injectDirectiveParser.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">const babelTypes = require(&apos;babel-types&apos;);
/**
 * Parses class methods and functions in order to detect the use of an _&quot;inject directive&quot;_ and
 * replace it with a static property.
 * This class works as a helper for a Babel plugin.
 * @example
 * // Input
 * class MyService {
 *   constructor(depOne, depTwo) {
 *     &apos;inject&apos;;
 *     ...
 *   }
 * }
 * // Output
 * class MyService {
 *   constructor(depOne, depTwo) {
 *     &apos;inject&apos;;
 *     ...
 *   }
 * }
 * MyService.inject = [&apos;depOne&apos;, &apos;depTwo&apos;]
 */
class InjectDirectiveParser {
  /**
   * @param {Path} file The information of the File Babel is processing.
   */
  constructor(file) {
    /**
     * A dictionary with the parser options.
     * @type {Object}
     * @property {String} directive The name of the directive it should find in order to apply the
     *                              transformation.
     * @property {String} property  The name of the property where the dependencies will be added.
     * @access protected
     * @ignore
     */
    this._options = this._parseOptions(file.opts);
    /**
     * The list of {@link Path} elements that were added via the _&quot;parse methods&quot;_. Once
     * {@link InjectDirectiveParser#transform} gets called, they will be processed and the
     * transformation applied.
     * @type {Array}
     * @access protected
     * @ignore
     */
    this._paths = [];
  }
  /**
   * This is called from a {@link ParserCallback} when the object being processed is a class
   * method.
   * @param {Path} path The information of the object being processed.
   */
  parseClassMethod(path) {
    // Only check for constructor methods that have the directive.
    if (
      path.node.kind === &apos;constructor&apos; &amp;&amp;
      this._hasDirective(path)
    ) {
      // Find the class declaration/expression for that constructor and add it to the list.
      path.getAncestry().some((ancestor) =&gt; {
        let stop = false;
        if (ancestor.isClassDeclaration() || ancestor.isClassExpression()) {
          stop = true;
          this._addPath(ancestor);
        }

        return stop;
      });
    }
  }
  /**
   * This is called from a {@link ParserCallback} when the object being processed is a function
   * expression/declaration.
   * @param {Path} path The information of the object being processed.
   */
  parseFunction(path) {
    // Check if it has the directive.
    if (this._hasDirective(path)) {
      // If it&apos;s a function declaration, add it to the list.
      if (babelTypes.isFunctionDeclaration(path.node)) {
        this._addPath(path);
      } else if (babelTypes.isVariableDeclarator(path.parent)) {
        /**
         * otherwise, if it&apos;s an expression (being declared through a variable), add the parent
         * path.
         */
        this._addPath(path.parentPath);
      }
    }
  }
  /**
   * This is called from {@link ProgramVisitorFinish}, it takes all the parsed elements and
   * processes them in order to apply the transformations.
   */
  transform() {
    this._paths.forEach((path) =&gt; this._transformPath(path));
  }
  /**
   * Adds a path to the list that will be processed, after checking that is not already there.
   * @param {Path} path The path to add.
   * @access protected
   * @ignore
   */
  _addPath(path) {
    if (!this._pathExists(path)) {
      this._paths.push(path);
    }
  }
  /**
   * Adds the property with the dependencies after an specific {@link Path}.
   * @param {Array}  params The list of parameters.
   * @param {Path}   path   The reference {@link Path}.
   * @param {String} name   The name of the function/method/variable _&quot;owner&quot;_ of the property.
   * @access protected
   * @ignore
   */
  _addPropertyAfterPath(params, path, name) {
    const newPath = Object.assign({}, path);
    newPath.node.trailingComments = [];
    newPath.parentPath.scope.crawl();
    newPath.insertAfter(this._createPropertyExpression(name, params));
  }
  /**
   * Tries to add the property with the dependencies after an specific {@link Path}. By _&quot;try&quot;_, it
   * means that it will check if the function is hoisted and in that case it will try to add it
   * on the top of the scope, otherwise, it will just add it after.
   * @param {Array}  params The list of parameters.
   * @param {Path}   path   The reference {@link Path}.
   * @param {String} name   The name of the function/method/variable _&quot;owner&quot;_ of the property.
   * @access protected
   * @ignore
   */
  _addPropertyBeforePath(params, path, name) {
    const binding = path.scope.getBinding(name);
    const expression = this._createPropertyExpression(name, params);
    if (binding &amp;&amp; binding.kind === &apos;hoisted&apos;) {
      let block = binding.scope.getBlockParent().path;
      if (block.isFunction()) {
        block = block.get(&apos;body&apos;);
      }

      block.unshiftContainer(&apos;body&apos;, [expression]);
    } else {
      path.parentPath.scope.crawl();
      path.insertAfter(expression);
    }
  }
  /**
   * Creates the declaration of the property and its value.
   * @param {String} name   The name of the function/method/variable _&quot;owner&quot;_ of the property.
   * @param {Array}  params The list of parameters the function/method receives.
   * @return {ExpressionStatement}
   * @access protected
   * @ignore
   */
  _createPropertyExpression(name, params) {
    const left = babelTypes.isNode(name) ? name : babelTypes.identifier(name);
    const paramsAsString = params.map((param) =&gt; (
      babelTypes.stringLiteral(this._getParamName(param))
    ));
    const list = babelTypes.arrayExpression(paramsAsString);
    const member = babelTypes.memberExpression(
      left,
      babelTypes.identifier(this._options.property)
    );
    return babelTypes.expressionStatement(babelTypes.assignmentExpression(&apos;=&apos;, member, list));
  }
  /**
   * A helper function that generates a unique ID for a given {@link Path}. This is used by
   * {@link InjectDirectiveParser#_addPath} when trying to identify if a path is already on the
   * list.
   * @param {Path} path The path for which the ID will be generated.
   * @return {String}
   * @access protected
   * @ignore
   */
  _generatePathId(path) {
    return `${path.node.start}-${path.node.end}`;
  }
  /**
   * Given the {@link Node} of a class declaration/expression, this method will try to find the
   * {@link Node} for its constructor.
   * @param {Node} clsNode A class declaration/expression node.
   * @return {?Node}
   * @access protected
   * @ignore
   */
  _getClassConstructor(clsNode) {
    return clsNode.body.body.find((node) =&gt; node.kind === &apos;constructor&apos;);
  }
  /**
   * Given a function/method parameter, this method will check if it&apos;s an actuall raw parameter,
   * in which case it will return it as it is, or an {@link AssignmentExpression}, where the name
   * is on the `left` property.
   * @param {string|AssignmentExpression} param The parameter information.
   * @return {string}
   * @access protected
   * @ignore
   */
  _getParamName(param) {
    const newParam = babelTypes.isAssignmentPattern(param) ?
      param.left :
      param;

    return newParam.name;
  }
  /**
   * Checks whether a functon/method has the required directive.
   * @param {Path} path The function/method path.
   * @return {Boolean}
   * @access protected
   * @ignore
   */
  _hasDirective(path) {
    let result = false;
    const { directives } = path.node.body;
    if (directives &amp;&amp; directives.length) {
      result = directives.some(({ value }) =&gt; value.value === this._options.directive);
    }

    return result;
  }
  /**
   * Checks whether a {@link Path} is already on the list that will be processed or not.
   * @param {Path} path The path to check.
   * @return {Boolean}
   * @access protected
   * @ignore
   */
  _pathExists(path) {
    const id = this._generatePathId(path);
    return this._paths.some((pathItem) =&gt; this._generatePathId(pathItem) === id);
  }
  /**
   * Generates a new set of options for the class by merging the received paramter and a set of
   * defaults. This is called from the constructor, using the recived file options as overwrites.
   * @param  {Object} [options={}] The options to overwrite the default ones.
   * @return {Object}
   * @property {string} directive The name of the directive the parser will look for.
   * @property {string} property  The name of the property where the dependencies will be defined.
   * @access protected
   * @ignore
   */
  _parseOptions(options = {}) {
    return Object.assign(
      {
        directive: &apos;inject&apos;,
        property: &apos;inject&apos;,
      },
      options
    );
  }
  /**
   * Processes and transform a given {@link Path} in order to add the required property.
   * @param {Path} originalPath The path to transform.
   * @access protected
   * @ignore
   */
  _transformPath(originalPath) {
    let path = originalPath;
    let { node } = path;

    let topPath;
    let name;
    if (babelTypes.isVariableDeclarator(path.node)) {
      topPath = path.parentPath;
      ({ name } = node.id);
      node = node.init;
      path = path.get(&apos;init&apos;);
    } else {
      topPath = path;
    }

    if (babelTypes.isExportDeclaration(topPath.parent)) {
      topPath = topPath.parentPath;
    }

    if (babelTypes.isClass(node)) {
      ({ name } = node.id);
      node = this._getClassConstructor(node);
    }

    if (node.params.length) {
      if (babelTypes.isFunctionExpression(node) || babelTypes.isClassMethod(node)) {
        this._addPropertyAfterPath(node.params, topPath, name);
      } else {
        this._addPropertyBeforePath(node.params, path, node.id.name);
      }
    }
  }
}

module.exports = InjectDirectiveParser;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
